package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/pierrec/cmdflag"
	"github.com/pierrec/packagen"
)

const (
	listSeparator = ','
	typeSeparator = '='
)

func init() {
	cli.MustAdd(cmdflag.Application{
		Name:  "single",
		Descr: "create a single file from a package",
		Args:  "<list of patterns matching the packages to be processed>",
		Err:   flag.ExitOnError,
		Init: func(set *flag.FlagSet) cmdflag.Handler {
			var o packagen.SingleOption
			o.Log = newLogger()
			var nogen bool
			set.BoolVar(&nogen, "nogen", false, "do not add the generate directive")

			set.StringVar(&o.NewPkgName, "newpkg", "",
				"new package name (default=current working dir package)")
			set.StringVar(&o.Prefix, "prefix", "",
				"prefix used to rename declarations (default=packageName_)")

			var mvtype string
			set.StringVar(&mvtype, "mvtype", "",
				fmt.Sprintf("list of named types to be renamed: old%cnew[%c ...]",
					typeSeparator, listSeparator))

			var rmtype string
			set.StringVar(&rmtype, "rmtype", "",
				fmt.Sprintf("list of named types to be removed: typename[%c ...]",
					listSeparator))

			var upconst string
			set.StringVar(&upconst, "const", "",
				fmt.Sprintf("list of integer constants to be updated: constname%cinteger[%c ...]",
					typeSeparator, listSeparator))

			var rmconst string
			set.StringVar(&rmconst, "rmconst", "",
				fmt.Sprintf("list of constants to be discarded: constname[%c ...]",
					typeSeparator))

			var outfile string
			set.StringVar(&outfile, "o", "", "write output to `file` (default=standard output)")

			return func(args ...string) (_ int, err error) {
				o.Patterns = args
				o.RmTypes = toMap(rmtype)
				o.Types, err = toMapString(mvtype)
				if err != nil {
					return 0, err
				}

				// Make sure that renamed types that need to be removed are also in the rm list.
				for src, tgt := range o.Types {
					if _, ok := o.RmTypes[src]; ok {
						o.RmTypes[tgt] = struct{}{}
					}
				}

				o.Const, err = toMapInt(upconst)
				o.RmConst = toMap(rmconst)
				if err != nil {
					return 0, err
				}
				var out io.Writer
				if outfile == "" {
					// Buffer standard output.
					buf := bufio.NewWriter(os.Stdout)
					defer buf.Flush()
					out = buf
				} else {
					f, err := os.Create(outfile)
					if err != nil {
						return 0, err
					}
					defer f.Close()
					out = f
				}
				// File header.
				_, err = fmt.Fprintf(out, "// DO NOT EDIT Code automatically generated.\n")
				if err != nil {
					return 0, err
				}
				if nogen {
					_, err = fmt.Fprintf(out, "// Generated by: go run github.com/pierrec/packagen/cmd/packagen %s\n\n",
						strings.Join(os.Args[1:], " "))
				} else {
					_, err = fmt.Fprintf(out, "//go:generate go run github.com/pierrec/packagen/cmd/packagen %s\n\n",
						strings.Join(os.Args[1:], " "))
				}
				if err != nil {
					return 0, err
				}

				return len(args), packagen.Single(out, o)
			}
		},
	})
}

func toMap(src string) map[string]struct{} {
	m := map[string]struct{}{}
	if src != "" {
		for _, s := range strings.Split(src, string(listSeparator)) {
			m[s] = struct{}{}
		}
	}
	return m
}

func toMapString(src string) (map[string]string, error) {
	m := map[string]string{}
	if src == "" {
		return m, nil
	}

	for _, kv := range strings.Split(src, string(listSeparator)) {
		i := strings.IndexByte(kv, typeSeparator)
		if i < 0 {
			return nil, fmt.Errorf("missing separator %c in %s", typeSeparator, kv)
		}
		m[kv[:i]] = kv[i+1:]
	}

	return m, nil
}

func toMapInt(src string) (map[string]int, error) {
	m := map[string]int{}
	if src == "" {
		return m, nil
	}

	for _, kv := range strings.Split(src, string(listSeparator)) {
		i := strings.IndexByte(kv, typeSeparator)
		if i < 0 {
			return nil, fmt.Errorf("missing separator %c in %s", typeSeparator, kv)
		}
		n, err := strconv.Atoi(kv[i+1:])
		if err != nil {
			return nil, err
		}
		m[kv[:i]] = n
	}

	return m, nil
}

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/renameio"
)

// Make bufio.Writer implement io.Close.
type buffer struct {
	*bufio.Writer
}

func (b *buffer) Close() error {
	return b.Writer.Flush()
}

func newSafeFile(fname string) (*safeFile, error) {
	t, err := renameio.TempFile("", fname)
	if err != nil {
		return nil, err
	}
	return &safeFile{t}, nil
}

// Provide a safe io.WriteCloser for file.
type safeFile struct {
	*renameio.PendingFile
}

func (so *safeFile) Close() error {
	if err := so.PendingFile.CloseAtomicallyReplace(); err != nil {
		return err
	}
	return so.PendingFile.Cleanup()
}

// Either return the file or a buffered stdout.
func initOutput(fname string, header, nogen bool) (out io.WriteCloser, err error) {
	if fname == "" {
		// Buffer standard output.
		out = &buffer{bufio.NewWriter(os.Stdout)}
	} else {
		out, err = newSafeFile(fname)
		if err != nil {
			return
		}
	}
	if !header {
		return
	}
	// Write the header.
	_, err = fmt.Fprintf(out, "// DO NOT EDIT Code automatically generated.\n")
	if err != nil {
		return
	}
	cmd := strings.TrimSuffix(filepath.Base(os.Args[0]), ".exe")
	args := strings.Join(os.Args[1:], " ")
	if nogen {
		_, err = fmt.Fprintf(out, "// Generated by: %s %s\n\n", cmd, args)
	} else {
		_, err = fmt.Fprintf(out, "//go:generate %s %s\n\n", cmd, args)
	}
	return
}
